#Feb 20, 17
##morning rain brought this discovery
Separation of time and spice is completely arbitrary and that distinction requires work of intellegence organizing and processing
the universe around. Simply, a fairly self contained component of spaceTime, complex enough to be self aware of its purpose - building itself.
In short, us.

##Heres why.
The universe is defining itself just like any component. Thats its program. The way it does it is the way you would think it would do it by
sequentially creating objects and using them in next tick of time to create more objects. Purely timewise approach. BUT, wait ... 
what are those objects its creating? On close observation they appear to be full of other objects being created in sequence and on and on.
There is the finest most refined unbreakable object - node of spiceTime. On the basic timewise level, these nodes are being created in
sequence and thats how universe expands - by building itself.
At some point in sequence, we get created, just another step in act of creation. Rather coalice into an organized structure and we start organizing those funny nodes around us into abstractions,
like into piles of beans - the components of spiceTime, objects. Each is a pile of nodes with invisible borders around it. Guess, visible
only to the annoited circle of your friends.
So, by wrapping this border around unsuspecting spiceTime nodes, we translate sequential time into space like structure. BUT, the universe 
keeps ticking its global clock passed the borders bootstrapping itself to existence. Its not concerned about us anymore. It created us in previous ticks
and uses us as a tool to build other things. 
What things. Why? The one we imagine with our minds, of course. We are building the universe with our thoughts.<br>
Tell me where i went wrong?

##This is how it is relevant to js code.
###Those objects are js functions. 
The border is the wrapper func around a sequence of statements and its prop is the local scope. Well, its own scope extended from parent by its home crew. If we manage to create a self contained component that need no help from that crew - we created a universe. In spiceTime lingo, we created a val flavored scope element. If the object is bound to its parent and all parents friends and, then, some others that come into its scope as props, we call it a func flavored element. The difference is syntax of access: vals croak like: myVal=scope.myVal, funcs bark like: scope.myFunc(props)<br>

###Can we set any of those vals and funcs?
You bet. But only for naked elements, the ones declared in index files. The reason is I get confused around wasting my time writing code in module files only to replace them later with code in another file. Why would anyone want to do that? If you know why, let me know.

###What are element types?
Its another abstraction abstracting time. Types are containers of props generated during each tick (each tick defines the type of what it creates) at the beginning of timeTick func. So, the func generates some intial tags to identify itself, we grab that partial knowledge and squarell it away in a dangeon of a type so we can descriminate and clishe the poor fellow at the first site. The main advantage is they provide syntax of declaration and type interlocking between scopes. Types are manifestation of the fact that before universe is done, we only have partial information to judge and reason about anything. They are the reason for the probobalistic nature of qm. You kinda know what it is but to know more, you have to wait. When it dawns on you, the physists call it quantum state collapse. Its not remarkable why it is so observer and time dependant. The act of measuremnt is collecting that partial info up to the point in spiceTime but filtered by the observer scope - we are all funcs, remember? QM is an abstraction and i'm about to toss it cos it so damn confusing.
spiceTime allows for very granular type definition. each type can be refined in many places, each refinement updates type in place. This helps circular deps but the bueaty is it allows clear definition of data flow between all functions in the hub of the local empire - index file. Then, anybody can grab that index file, run off with it and generate scope boilerplate on his own time, pehaps even using automation or a gui system. I see a cms much better then drupal ever wanted to be. 
Types are not given by the god or law giver of a bootstrap func. Types are composed from the type scope of visible types in each local scope. If the type is not visible where you need it, just move its definition up scope and down the periscope.

###What about composing apps.
We dont compose apps. We compose types of val flavor. This is what an app is - a sandboxed function scope. Happy app composing. When done, instantiate the type to generate a boilerplate of a type of app. Then, fill in a few blond (lone?) bombshell one liners and your app is done.

### WAIT ... what do we do with styles?
Style is the beauty property of each spiceNode. That means, its another scope like property and gets composed out of styles of all locals. Its not that mind blowing. We (some of us) normally do it in a separate sass file structure that parallels structure of ui components. All spiceTime proposing is to unify those two identical spaces - no parallel universes, gives me a headache. Then, just go ahead and compose them and import them and love them for the beauty they bring to the spiceTime. I know you would but spiceTime buttler comes to your service and does it. All you need to do is stick a local sass file into the folder. It will be roped in and packed into composed file visible to the parent. An advantage is for each local element of scope, its beaty is more then skin deep but reflects the structure of all its downscope parts. Now, complete customization of downscope styles is possible with greate precision and granularity. Styles might be combined into type for screen and reactComponent elements.

### Documentation?
Yep, another scope property of spiceNode. Its very efficient and very intuative to make docs granular and fractal. I will not go against the flow of spice.

##Qm in a nutshell: I'm the nut and spiceTime is the shell.
So, vals are free agents. we have no influence on them and they leave us alone till they ready to deliver their entire being for our purpose, when they are done. They kinda tick producing props at each tick like the rest of the mad house but they dont need our help at all. So, to us it looks like they got done instantly in the same tick we accessed(invoked) them. They produce a container full of props if they are clocked. E.g. a screen can be made into a val element. It will return react component func with reducers and permissions as static props of that func.
Funcs are our slaves, we rope them in with control strings and we abuse them many times over. Worse, we send them to foreign lands to perform our bidding as the messangers. But, however far they stray, they are still bound to our local scope and, when executed by some cruel master, they affect our local world. That IS the essence of spooky action at a distance (Einstein was an increadable mind but we all fall into one box or another, beware), quantum entanglement and composed quantum state, which is collection of possible values (combinations of them) assigned by func to elements in outer scope. Thats observables as known in qm. We can not see inside func scope, so, all its locals are part of its state but they are hidden in a clouser. 

##A primer to the nature of mass
I dont know about god's creation but in my spiceTime world we have naked elements and structured elements - one is declared, defined and initialized in the index file and the other has a nice modular home (in a trailer park?). Yet some have even more structure then that - a whole world of inner function scopes, folders. Stationary mass is the ammount of that structure. The heavy ones are hard to create. They abstract a lot of information/organization inside. The naked puppies are the lightest, no matter val or func cuteness factor. This is stationary mass - amount of energy/information/structure/space(remember, structure is space) needed to create them. 
To summurize - naked elements have zero space dimension, no structure and zero stationary mass. The more structure, the heavier the load and more space they take up so its harder to get them moving, excited by props that take time to perculate down scope. We percive this as acceleration and heavy mass effects slow acceleration.
Ok. What about kenetic energy - you kick the ball and it flys to stars, at least to mars. Thats the information you feed to your functional ball, the props, to get them all excited and pregnant, start running around ticking to themselves till they spit out some other particle to everyone releif. Correction. They dont tick independantly. Wrong universe. In spiceTime, and seems in spaceTime as well, they share ticks with the rest of us. Each global tick producers a result of the same name from all elements. Values do it instantly from our point of view and produce an object full of same props that func took explicit tick control from parent scope. Basically, we decide at each time tick when to tickle our children and what to do with that stuff they produce in their pants when they get too excited. This happens to be very useful for composing things like reducers perculating from tree branches to the roots while being composed. All boilerplate is out of site encapsulated in the
type definition. All you do is name your screen component file myScreen$screen and all boilerplate is out of your mind releasing mental space for better things.

##Now we will take on quantum field theory. 
Remember two flavors of particles - leptons and barrions. Can you guess who is who? Vals are ... barrions. They dont interact with any strangers when we send them away cos they have no acess to scope. 
Leptons are func elements. We bring them to existence,like any other element, from types - functions that create them but defined before hand, in the previous ticks (i know, duality and confusion again. Its an abstraction and it tries to organize objects with extremely subtle differences and has limits). We dont hold them for long but feed them prop fuel, get them all excited. They run around all pregnant, tick for a while (nothing is instant) and spit out result - another particle. Those props are just particles, funcs or vals. They eat them all, produce side effects and spit some other particles at the end. Side effects is the force they mediate, props are the energy it takes to produce that force. Result is leftover energy/information.

This is all there is to spiceTime, the spice of rhyme, with smell of thyme, and time its brother, with space to bother, to teach us self, to know thyself.

Roadmap: Watch for gravity to emerge. I know its there cos any time spaceTime is constructed with spaceTime nodes, gravity emerges. Perhaps, translation of time ticks to down scopes - names change and time scale as well by skipping some ticks, slicing time. The local differences in time somehow twist the structure. I dont know what it means but at some point there will be a use case where it will be needed and we might find out what the hell gravity really is, w/o the need for monstrous colliders size of universe. Its all the same, might as well study the simplest processes like a ToDos script.
Then, gravity might be evolution of script structure itself to become more efficient at solving its result. An adaptive, self organizing process? That sounds intellegent. Do WE have to do something with gravity? Does not matter untill i have the need for that abstraction.

